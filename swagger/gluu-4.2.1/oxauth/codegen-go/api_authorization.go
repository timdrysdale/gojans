
/*
 * oxAuth
 *
 * oxAuth - OAuth 2.0 server; OpenID Connect Provider (OP) & UMA Authorization Server (AS)
 *
 * API version: 4.2
 * Contact: yuriyz@gluu.org
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */
package swagger

import (
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"github.com/antihax/optional"
)

// Linger please
var (
	_ context.Context
)

type AuthorizationApiService service
/*
AuthorizationApiService Performs backchannel authorization of the end-user.
The Backchannel Authentication Endpoint is used to initiate an out-of-band authentication of the end-user.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param clientId
 * @param scope
 * @param clientNotificationToken
 * @param acrValues
 * @param loginHintToken
 * @param idTokenHint
 * @param loginHint
 * @param bindingMessage
 * @param userCode
 * @param requestedExpiry
@return BackchannelAuthorization
*/
func (a *AuthorizationApiService) BcAuthorize(ctx context.Context, clientId string, scope string, clientNotificationToken string, acrValues string, loginHintToken string, idTokenHint string, loginHint string, bindingMessage string, userCode string, requestedExpiry int32) (BackchannelAuthorization, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue BackchannelAuthorization
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/bc-authorize"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("client_id", parameterToString(clientId, ""))
	localVarFormParams.Add("scope", parameterToString(scope, ""))
	localVarFormParams.Add("client_notification_token", parameterToString(clientNotificationToken, ""))
	localVarFormParams.Add("acr_values", parameterToString(acrValues, ""))
	localVarFormParams.Add("login_hint_token", parameterToString(loginHintToken, ""))
	localVarFormParams.Add("id_token_hint", parameterToString(idTokenHint, ""))
	localVarFormParams.Add("login_hint", parameterToString(loginHint, ""))
	localVarFormParams.Add("binding_message", parameterToString(bindingMessage, ""))
	localVarFormParams.Add("user_code", parameterToString(userCode, ""))
	localVarFormParams.Add("requested_expiry", parameterToString(requestedExpiry, ""))
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v BackchannelAuthorization
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 401 {
			var v InlineResponse401
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
AuthorizationApiService The Authorization Endpoint performs Authentication of the End-User.
End-User Authentication and Authorization done by sending the User Agent to the Authorization Endpoint using request parameters defined by OAuth 2.0 and OpenID Connect.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param scope OpenID Connect requests MUST contain the openid scope value. If the openid scope value is not present, the behavior is entirely unspecified. Other scope values MAY be present.
 * @param responseType OAuth 2.0 Response Type value that determines the authorization processing flow to be used, including what parameters are returned from the endpoints used.
 * @param clientId OAuth 2.0 Client Identifier valid at the Authorization Server.
 * @param redirectUri Redirection URI to which the response will be sent. This URI MUST exactly match one of the Redirection URI values for the Client pre-registered at the OpenID Provider.
 * @param optional nil or *AuthorizationApiGetAuthorizeOpts - Optional Parameters:
     * @param "State" (optional.String) -  Opaque value used to maintain state between the request and the callback.
     * @param "ResponseMode" (optional.String) -  Informs the Authorization Server of the mechanism to be used for returning parameters from the Authorization Endpoint.
     * @param "Nonce" (optional.String) -  String value used to associate a Client session with an ID Token, and to mitigate replay attacks.
     * @param "Display" (optional.String) -  ASCII string value that specifies how the Authorization Server displays the authentication and consent user interface pages to the End-User.
     * @param "Prompt" (optional.String) -  Space delimited, case sensitive list of ASCII string values that specifies whether the Authorization Server prompts the End-User for reauthentication and consent. The defined values are - none, login, consent, select_account.
     * @param "MaxAge" (optional.Int32) -  Maximum Authentication Age. Specifies the allowable elapsed time in seconds since the last time the End-User was actively authenticated by the OP.
     * @param "UiLocales" (optional.String) -  End-User&#x27;s preferred languages and scripts for the user interface, represented as a space-separated list of BCP47 [RFC5646] language tag values, ordered by preference.
     * @param "IdTokenHint" (optional.String) -  ID Token previously issued by the Authorization Server being passed as a hint about the End-User&#x27;s current or past authenticated session with the Client. If the End-User identified by the ID Token is logged in or is logged in by the request, then the Authorization Server returns a positive response.
     * @param "LoginHint" (optional.String) -  Hint to the Authorization Server about the login identifier the End-User might use to log in (if necessary).
     * @param "AcrValues" (optional.String) -  Requested Authentication Context Class Reference values. Space-separated string that specifies the acr values that the Authorization Server is being requested to use for processing this Authentication Request, with the values appearing in order of preference.
     * @param "AmrValues" (optional.String) -  AMR Values.
     * @param "Request" (optional.String) -  This parameter enables OpenID Connect requests to be passed in a single, self-contained parameter and to be optionally signed and/or encrypted. The parameter value is a Request Object value. It represents the request as a JWT whose Claims are the request parameters.
     * @param "RequestUri" (optional.String) -  This parameter enables OpenID Connect requests to be passed by reference, rather than by value. The request_uri value is a URL using the https scheme referencing a resource containing a Request Object value, which is a JWT containing the request parameters.
     * @param "RequestSessionId" (optional.String) -  Request session id.
     * @param "SessionId" (optional.String) -  Session id of this call.
     * @param "OriginHeaders" (optional.String) -  Origin headers. Used in custom workflows.
     * @param "CodeChallenge" (optional.String) -  PKCE code challenge.
     * @param "CodeChallengeMethod" (optional.String) -  PKCE code challenge method.
     * @param "CustomResponseHeaders" (optional.String) -  Custom Response Headers.
     * @param "Claims" (optional.String) -  Requested Claims.
     * @param "AuthReqId" (optional.String) -  CIBA authentication request Id.

*/

type AuthorizationApiGetAuthorizeOpts struct {
    State optional.String
    ResponseMode optional.String
    Nonce optional.String
    Display optional.String
    Prompt optional.String
    MaxAge optional.Int32
    UiLocales optional.String
    IdTokenHint optional.String
    LoginHint optional.String
    AcrValues optional.String
    AmrValues optional.String
    Request optional.String
    RequestUri optional.String
    RequestSessionId optional.String
    SessionId optional.String
    OriginHeaders optional.String
    CodeChallenge optional.String
    CodeChallengeMethod optional.String
    CustomResponseHeaders optional.String
    Claims optional.String
    AuthReqId optional.String
}

func (a *AuthorizationApiService) GetAuthorize(ctx context.Context, scope string, responseType string, clientId string, redirectUri string, localVarOptionals *AuthorizationApiGetAuthorizeOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/authorize"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("scope", parameterToString(scope, ""))
	localVarQueryParams.Add("response_type", parameterToString(responseType, ""))
	localVarQueryParams.Add("client_id", parameterToString(clientId, ""))
	localVarQueryParams.Add("redirect_uri", parameterToString(redirectUri, ""))
	if localVarOptionals != nil && localVarOptionals.State.IsSet() {
		localVarQueryParams.Add("state", parameterToString(localVarOptionals.State.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ResponseMode.IsSet() {
		localVarQueryParams.Add("response_mode", parameterToString(localVarOptionals.ResponseMode.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Nonce.IsSet() {
		localVarQueryParams.Add("nonce", parameterToString(localVarOptionals.Nonce.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Display.IsSet() {
		localVarQueryParams.Add("display", parameterToString(localVarOptionals.Display.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Prompt.IsSet() {
		localVarQueryParams.Add("prompt", parameterToString(localVarOptionals.Prompt.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MaxAge.IsSet() {
		localVarQueryParams.Add("max_age", parameterToString(localVarOptionals.MaxAge.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UiLocales.IsSet() {
		localVarQueryParams.Add("ui_locales", parameterToString(localVarOptionals.UiLocales.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IdTokenHint.IsSet() {
		localVarQueryParams.Add("id_token_hint", parameterToString(localVarOptionals.IdTokenHint.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LoginHint.IsSet() {
		localVarQueryParams.Add("login_hint", parameterToString(localVarOptionals.LoginHint.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AcrValues.IsSet() {
		localVarQueryParams.Add("acr_values", parameterToString(localVarOptionals.AcrValues.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AmrValues.IsSet() {
		localVarQueryParams.Add("amr_values", parameterToString(localVarOptionals.AmrValues.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Request.IsSet() {
		localVarQueryParams.Add("request", parameterToString(localVarOptionals.Request.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RequestUri.IsSet() {
		localVarQueryParams.Add("request_uri", parameterToString(localVarOptionals.RequestUri.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RequestSessionId.IsSet() {
		localVarQueryParams.Add("request_session_id", parameterToString(localVarOptionals.RequestSessionId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SessionId.IsSet() {
		localVarQueryParams.Add("session_id", parameterToString(localVarOptionals.SessionId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OriginHeaders.IsSet() {
		localVarQueryParams.Add("origin_headers", parameterToString(localVarOptionals.OriginHeaders.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CodeChallenge.IsSet() {
		localVarQueryParams.Add("code_challenge", parameterToString(localVarOptionals.CodeChallenge.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CodeChallengeMethod.IsSet() {
		localVarQueryParams.Add("code_challenge_method", parameterToString(localVarOptionals.CodeChallengeMethod.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CustomResponseHeaders.IsSet() {
		localVarQueryParams.Add("custom_response_headers", parameterToString(localVarOptionals.CustomResponseHeaders.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Claims.IsSet() {
		localVarQueryParams.Add("claims", parameterToString(localVarOptionals.Claims.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AuthReqId.IsSet() {
		localVarQueryParams.Add("auth_req_id", parameterToString(localVarOptionals.AuthReqId.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 302 {
			var v AuthorizeError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
AuthorizationApiService The Authorization Endpoint performs Authentication of the End-User.
End-User Authentication and Authorization done by sending the User Agent to the Authorization Endpoint using request parameters defined by OAuth 2.0 and OpenID Connect.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param scope
 * @param responseType
 * @param clientId
 * @param redirectUri
 * @param state
 * @param responseMode
 * @param nonce
 * @param display
 * @param prompt
 * @param maxAge
 * @param uiLocales
 * @param idTokenHint
 * @param loginHint
 * @param acrValues
 * @param amrValues
 * @param request
 * @param requestUri
 * @param requestSessionId
 * @param sessionId
 * @param originHeaders
 * @param codeChallenge
 * @param codeChallengeMethod
 * @param customResponseHeaders
 * @param claims

*/
func (a *AuthorizationApiService) PostAuthorize(ctx context.Context, scope string, responseType string, clientId string, redirectUri string, state string, responseMode string, nonce string, display string, prompt string, maxAge int32, uiLocales string, idTokenHint string, loginHint string, acrValues string, amrValues string, request string, requestUri string, requestSessionId string, sessionId string, originHeaders string, codeChallenge string, codeChallengeMethod string, customResponseHeaders string, claims string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/authorize"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("scope", parameterToString(scope, ""))
	localVarFormParams.Add("response_type", parameterToString(responseType, ""))
	localVarFormParams.Add("client_id", parameterToString(clientId, ""))
	localVarFormParams.Add("redirect_uri", parameterToString(redirectUri, ""))
	localVarFormParams.Add("state", parameterToString(state, ""))
	localVarFormParams.Add("response_mode", parameterToString(responseMode, ""))
	localVarFormParams.Add("nonce", parameterToString(nonce, ""))
	localVarFormParams.Add("display", parameterToString(display, ""))
	localVarFormParams.Add("prompt", parameterToString(prompt, ""))
	localVarFormParams.Add("max_age", parameterToString(maxAge, ""))
	localVarFormParams.Add("ui_locales", parameterToString(uiLocales, ""))
	localVarFormParams.Add("id_token_hint", parameterToString(idTokenHint, ""))
	localVarFormParams.Add("login_hint", parameterToString(loginHint, ""))
	localVarFormParams.Add("acr_values", parameterToString(acrValues, ""))
	localVarFormParams.Add("amr_values", parameterToString(amrValues, ""))
	localVarFormParams.Add("request", parameterToString(request, ""))
	localVarFormParams.Add("request_uri", parameterToString(requestUri, ""))
	localVarFormParams.Add("request_session_id", parameterToString(requestSessionId, ""))
	localVarFormParams.Add("session_id", parameterToString(sessionId, ""))
	localVarFormParams.Add("origin_headers", parameterToString(originHeaders, ""))
	localVarFormParams.Add("code_challenge", parameterToString(codeChallenge, ""))
	localVarFormParams.Add("code_challenge_method", parameterToString(codeChallengeMethod, ""))
	localVarFormParams.Add("custom_response_headers", parameterToString(customResponseHeaders, ""))
	localVarFormParams.Add("claims", parameterToString(claims, ""))
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 302 {
			var v AuthorizeError
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
